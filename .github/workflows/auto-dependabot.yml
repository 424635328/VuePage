# ========================================================================================
# Dependabot Observatory: 全自动 Dependabot PR 处理工作流 (v3.2 - 兼容性修复版)
# ========================================================================================
#
# 这是一个高级工作流，用于全自动管理 Dependabot 提交的拉取请求（PR）。
# 它扮演着“天文台”（Observatory）的角色，在所有CI检查完成后，智能地决定是
# 自动合并、请求人工审查还是关闭PR，并发表一份详细的报告。
#
# 核心特性 (v3.2):
#   - 【修复】在 `dependabot/fetch-metadata` 步骤中明确传递 PR 编号，以兼容 `check_suite` 触发器。
#   - 引入"决策引擎"，将所有逻辑判断集中处理，生成明确的决策(MERGE, REVIEW, CLOSE)和报告。
#   - 提供极其详尽的报告，无论成功、失败还是需要审查，都会清晰列出原因和检查项状态。
#   - 智能区分有无分支保护规则的场景，并采取不同策略。
#   - 统一的执行步骤，让工作流结构更清晰。
#
name: Dependabot Observatory

# ----------------------------------------------------------------------------------------
# 触发器（Trigger）
# ----------------------------------------------------------------------------------------
on:
  check_suite:
    types:
      - completed

# ----------------------------------------------------------------------------------------
# 并发控制（Concurrency）
# ----------------------------------------------------------------------------------------
concurrency:
  group: ${{ github.repository }}-${{ github.event.check_suite.pull_requests[0].number }}-observatory
  cancel-in-progress: true

jobs:
  handle_dependabot_pr:
    # ------------------------------------------------------------------------------------
    # 作业执行条件（Job Condition）
    # ------------------------------------------------------------------------------------
    if: >
      github.actor == 'dependabot[bot]' &&
      github.event.check_suite.pull_requests[0]
    runs-on: ubuntu-latest
    
    # ------------------------------------------------------------------------------------
    # 权限（Permissions）
    # ------------------------------------------------------------------------------------
    permissions:
      pull-requests: write # 允许评论、合并和关闭 PR。
      contents: write      # 允许合并 PR (因为合并操作会写入 base 分支)。

    steps:
      - name: "Checkout: 克隆代码仓库"
        uses: actions/checkout@v4

      - name: "Setup: 校验依赖工具"
        run: |
          set -euo pipefail
          gh --version
          jq --version
          echo "✅ 所有依赖工具均可用。"

      - name: "Step 1: 提取 PR 关键信息"
        id: pr-info
        run: |
          set -euo pipefail
          PR_NUMBER="${{ github.event.check_suite.pull_requests[0].number }}"
          PR_HEAD_SHA="${{ github.event.check_suite.head_sha }}"
          
          if [ -z "$PR_NUMBER" ] || [ -z "$PR_HEAD_SHA" ]; then
            echo "❌ 错误：无法从事件中找到关联的 PR 编号或头部提交 SHA。"
            exit 1
          fi
          
          BASE_BRANCH=$(gh pr view "$PR_NUMBER" --json baseRefName --jq '.baseRefName')
          
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
      # 【关键修复】
      # 此处添加了 `pr-number` 输入。
      # 原因：工作流由 `check_suite` 事件触发，其上下文与 `pull_request` 事件不同。
      # `dependabot/fetch-metadata` action 默认期望从 `pull_request` 事件上下文中自动
      # 寻找PR信息。由于触发器不同，我们必须显式地将 "Step 1" 中提取的PR编号传递给它，
      # 这样它才能正确地找到并分析PR的元数据，避免因找不到上下文而报错退出。
      # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
      - name: "Step 2: 获取 Dependabot 元数据"
        id: dependabot-metadata
        uses: dependabot/fetch-metadata@v2.2.0
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"
          pr-number: ${{ steps.pr-info.outputs.pr_number }} # <--- 这是唯一的修改点

      # ========================================================================================
      # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 核心决策引擎 ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
      # ========================================================================================
      - name: "Step 3: Decision Engine & Report Generator"
        id: engine
        run: |
          set -euo pipefail
          echo "🧠 [Decision Engine] 开始分析 PR #${{ steps.pr-info.outputs.pr_number }}..."
          
          # --- 1. 信息收集 ---
          ALL_CHECKS_JSON=$(gh api "repos/${{ github.repository }}/commits/${{ steps.pr-info.outputs.pr_head_sha }}/check-runs" --jq '.check_runs')
          REQUIRED_CHECKS_JSON=$(gh api "repos/${{ github.repository }}/branches/${{ steps.pr-info.outputs.base_branch }}/protection" --jq '.required_status_checks.contexts' 2>/dev/null || echo "[]")
          UPDATE_TYPE="${{ steps.dependabot-metadata.outputs.update-type }}"
          
          # 检查 UPDATE_TYPE 是否为空，如果为空则说明元数据获取失败
          if [ -z "$UPDATE_TYPE" ]; then
            echo "❌ 错误：无法从 dependabot/fetch-metadata 获取更新类型 (update-type)。"
            echo "这可能意味着上一步骤失败或者这不是一个有效的 Dependabot PR。"
            exit 1
          fi
          
          DECISION="CLOSE" # 默认决策为关闭，除非所有条件都满足
          CHECKS_PASSED=false
          FAILURE_REASON=""

          # --- 2. 检查CI状态 ---
          if [[ "$(echo "$REQUIRED_CHECKS_JSON" | jq 'if type=="array" and length==0 then "empty" else "ok" end')" == '"empty"' ]]; then
            # --- 场景一：没有配置分支保护规则 ---
            echo "ℹ️ 场景：未配置必需检查。将检查是否存在任何明确失败(failure)的检查项。"
            if echo "$ALL_CHECKS_JSON" | jq -e 'any(.conclusion == "failure")'; then
              FAILED_CHECKS=$(echo "$ALL_CHECKS_JSON" | jq -r '[.[] | select(.conclusion == "failure") | "`" + .name + "` (状态: `failure`)"] | join("\n- ")')
              FAILURE_REASON="一个或多个CI检查明确失败了:\n- $FAILED_CHECKS"
            else
              CHECKS_PASSED=true
            fi
          else
            # --- 场景二：已配置分支保护规则 ---
            echo "ℹ️ 场景：已配置必需检查。将严格验证所有规则。"
            REQUIRED_CHECKS=$(echo "$REQUIRED_CHECKS_JSON" | jq -r '.[]')
            FAILED_CHECKS=""
            while IFS= read -r CHECK_NAME; do
              CONCLUSION=$(echo "$ALL_CHECKS_JSON" | jq -r --arg name "$CHECK_NAME" '(.[] | select(.name == $name)) | .conclusion' | tail -n 1)
              if [[ "$CONCLUSION" != "success" ]]; then
                FAILED_CHECKS+="- 必需检查 \`$CHECK_NAME\` 未通过 (实际状态: \`${CONCLUSION:-Not Found}\`).\n"
              fi
            done <<< "$REQUIRED_CHECKS"
            
            if [ -z "$FAILED_CHECKS" ]; then
              CHECKS_PASSED=true
            else
              FAILURE_REASON="一个或多个必需的分支保护检查未通过:\n$FAILED_CHECKS"
            fi
          fi

          # --- 3. 根据CI结果和更新类型做出最终决策 ---
          if $CHECKS_PASSED; then
            echo "✅ 所有相关检查均已通过。"
            if [[ "$UPDATE_TYPE" == "version-update:semver-major" ]]; then
              DECISION="REVIEW"
            else
              DECISION="MERGE"
            fi
          else
            echo "❌ 检查未通过。决策：关闭PR。"
            DECISION="CLOSE"
          fi

          # --- 4. 生成详细的报告内容 ---
          delimiter=$(openssl rand -hex 8) # 生成一个唯一的定界符
          
          generate_report() {
            case "$1" in
              MERGE)
                SUCCESS_CHECKS=$(echo "$ALL_CHECKS_JSON" | jq -r '[.[] | select(.conclusion == "success") | "`" + .name + "`"] | join(", ")')
                cat <<EOF
          ✅ **天文台报告：自动合并已启用**

          所有必需的CI检查均已通过，且此更新为 **非重大版本更新** (\`${UPDATE_TYPE}\`)。已为此PR启用自动合并（Auto-merge）。

          ---
          **✔ 通过的检查项:**
          ${SUCCESS_CHECKS}
          EOF
                ;;
              REVIEW)
                SUCCESS_CHECKS=$(echo "$ALL_CHECKS_JSON" | jq -r '[.[] | select(.conclusion == "success") | "`" + .name + "`"] | join(", ")')
                cat <<EOF
          ⚠️ **天文台报告：需要人工审查**

          所有必需的CI检查均已通过，但这是一个 **重大版本更新** (major version update)，可能包含不兼容的变更，需要人工审查和批准后才能合并。

          ---
          **✔ 通过的检查项:**
          ${SUCCESS_CHECKS}
          EOF
                ;;
              CLOSE)
                WORKFLOW_URL="https://github.com/${{ github.repository }}/pull/${{ steps.pr-info.outputs.pr_number }}/checks"
                cat <<EOF
          🚨 **天文台报告：自动关闭**

          检测到CI检查存在问题，此 PR 将被自动关闭。

          ---
          **📋 诊断报告:**
          ${FAILURE_REASON}
          ---
          请访问以下链接审查所有检查项的详细情况：
          **[查看所有 PR 检查](${WORKFLOW_URL})**
          EOF
                ;;
            esac
          }

          REPORT_BODY=$(generate_report "$DECISION")

          # --- 5. 设置输出 ---
          echo "决策: $DECISION"
          # 使用HEREDOC将多行字符串赋值给GITHUB_OUTPUT
          {
            echo "decision=$DECISION"
            echo "report_body<<$delimiter"
            echo "$REPORT_BODY"
            echo "$delimiter"
          } >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ========================================================================================
      # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 统一执行操作 ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
      # ========================================================================================
      - name: "Step 4: Execute Decision"
        run: |
          set -euo pipefail
          DECISION="${{ steps.engine.outputs.decision }}"
          REPORT_BODY="${{ steps.engine.outputs.report_body }}"
          PR_NUMBER="${{ steps.pr-info.outputs.pr_number }}"

          echo "🎬 执行决策: $DECISION"
          
          # 始终先发表评论
          echo "发表评论..."
          # 使用 --body-file - 来从标准输入读取多行正文，这是最安全的方式
          echo "$REPORT_BODY" | gh pr comment "$PR_NUMBER" --body-file -

          # 根据决策执行相应操作
          case $DECISION in
            MERGE)
              echo "启用自动合并..."
              gh pr merge "$PR_NUMBER" --auto --squash
              ;;
            REVIEW)
              echo "操作完成，等待人工审查。"
              ;;
            CLOSE)
              echo "关闭PR..."
              gh pr close "$PR_NUMBER"
              ;;
          esac
          echo "✅ 操作执行完毕。"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}